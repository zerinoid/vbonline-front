{"ast":null,"code":"/*! @name m3u8-parser @version 4.4.0 @license Apache-2.0 */\nimport window from 'global/window';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implementation that handles event dispatching.\n *\n * @class Stream\n */\n\n\nvar Stream = /*#__PURE__*/function () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n    var i;\n    var length;\n    var args;\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      length = callbacks.length;\n\n      for (i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      args = Array.prototype.slice.call(arguments, 1);\n      length = callbacks.length;\n\n      for (i = 0; i < length; ++i) {\n        callbacks[i].apply(this, args);\n      }\n    }\n  }\n  /**\n   * Destroys the stream and cleans up.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\n\nvar LineStream = /*#__PURE__*/function (_Stream) {\n  _inheritsLoose(LineStream, _Stream);\n\n  function LineStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.buffer = '';\n    return _this;\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  var _proto = LineStream.prototype;\n\n  _proto.push = function push(data) {\n    var nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  };\n\n  return LineStream;\n}(Stream);\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\n\nvar attributeSeparator = function attributeSeparator() {\n  var key = '[^=]*';\n  var value = '\"[^\"]*\"|[^,]*';\n  var keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nvar parseAttributes = function parseAttributes(attributes) {\n  // split the string using attributes as the separator\n  var attrs = attributes.split(attributeSeparator());\n  var result = {};\n  var i = attrs.length;\n  var attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nvar ParseStream = /*#__PURE__*/function (_Stream) {\n  _inheritsLoose(ParseStream, _Stream);\n\n  function ParseStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.customParsers = [];\n    _this.tagMappers = [];\n    return _this;\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  var _proto = ParseStream.prototype;\n\n  _proto.push = function push(line) {\n    var _this2 = this;\n\n    var match;\n    var event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    var newLines = this.tagMappers.reduce(function (acc, mapper) {\n      var mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(function (newLine) {\n      for (var i = 0; i < _this2.customParsers.length; i++) {\n        if (_this2.customParsers[i].call(_this2, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        _this2.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n\n        return;\n      }\n\n      match = /^#EXTINF:?([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#ZEN-TOTAL-DURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'totalduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'byterange'\n        };\n\n        if (match[1]) {\n          event.length = parseInt(match[1], 10);\n        }\n\n        if (match[2]) {\n          event.offset = parseInt(match[2], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          var attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            var _attributes$BYTERANGE = attributes.BYTERANGE.split('@'),\n                length = _attributes$BYTERANGE[0],\n                offset = _attributes$BYTERANGE[1];\n\n            event.byterange = {};\n\n            if (length) {\n              event.byterange.length = parseInt(length, 10);\n            }\n\n            if (offset) {\n              event.byterange.offset = parseInt(offset, 10);\n            }\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            var split = event.attributes.RESOLUTION.split('x');\n            var resolution = {};\n\n            if (split[0]) {\n              resolution.width = parseInt(split[0], 10);\n            }\n\n            if (split[1]) {\n              resolution.height = parseInt(split[1], 10);\n            }\n\n            event.attributes.RESOLUTION = resolution;\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-START:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      } // unknown tag type\n\n\n      _this2.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n  ;\n\n  _proto.addParser = function addParser(_ref) {\n    var _this3 = this;\n\n    var expression = _ref.expression,\n        customType = _ref.customType,\n        dataParser = _ref.dataParser,\n        segment = _ref.segment;\n\n    if (typeof dataParser !== 'function') {\n      dataParser = function dataParser(line) {\n        return line;\n      };\n    }\n\n    this.customParsers.push(function (line) {\n      var match = expression.exec(line);\n\n      if (match) {\n        _this3.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType: customType,\n          segment: segment\n        });\n\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n  ;\n\n  _proto.addTagMapper = function addTagMapper(_ref2) {\n    var expression = _ref2.expression,\n        map = _ref2.map;\n\n    var mapFn = function mapFn(line) {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  };\n\n  return ParseStream;\n}(Stream);\n\nfunction decodeB64ToUint8Array(b64Text) {\n  var decodedString = window.atob(b64Text || '');\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\n\n\nvar Parser = /*#__PURE__*/function (_Stream) {\n  _inheritsLoose(Parser, _Stream);\n\n  function Parser() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.lineStream = new LineStream();\n    _this.parseStream = new ParseStream();\n\n    _this.lineStream.pipe(_this.parseStream);\n    /* eslint-disable consistent-this */\n\n\n    var self = _assertThisInitialized(_this);\n    /* eslint-enable consistent-this */\n\n\n    var uris = [];\n    var currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    var currentMap; // if specified, the active decryption key\n\n    var _key;\n\n    var noop = function noop() {};\n\n    var defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    var widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    var currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    _this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: []\n    }; // update the manifest with the m3u8 entry from the parse stream\n\n    _this.parseStream.on('data', function (entry) {\n      var mediaGroup;\n      var rendition;\n      ({\n        tag: function tag() {\n          // switch based on the tag type\n          (({\n            'allow-cache': function allowCache() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n            byterange: function byterange() {\n              var byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  this.trigger('info', {\n                    message: 'defaulting offset to zero'\n                  });\n                  entry.offset = 0;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n            },\n            endlist: function endlist() {\n              this.manifest.endList = true;\n            },\n            inf: function inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n            key: function key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                _key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                var VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = {\n                  'com.widevine.alpha': {\n                    attributes: {\n                      schemeIdUri: entry.attributes.KEYFORMAT,\n                      // remove '0x' from the key id string\n                      keyId: entry.attributes.KEYID.substring(2)\n                    },\n                    // decode the base64-encoded PSSH box\n                    pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                  }\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              _key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                _key.iv = entry.attributes.IV;\n              }\n            },\n            'media-sequence': function mediaSequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n            'discontinuity-sequence': function discontinuitySequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n            'playlist-type': function playlistType() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n            map: function map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n            },\n            'stream-inf': function streamInf() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n            media: function media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n            discontinuity: function discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n            'program-date-time': function programDateTime() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n            },\n            targetduration: function targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n            },\n            totalduration: function totalduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid total duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.totalDuration = entry.duration;\n            },\n            start: function start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n            'cue-out': function cueOut() {\n              currentUri.cueOut = entry.data;\n            },\n            'cue-out-cont': function cueOutCont() {\n              currentUri.cueOutCont = entry.data;\n            },\n            'cue-in': function cueIn() {\n              currentUri.cueIn = entry.data;\n            }\n          })[entry.tagType] || noop).call(self);\n        },\n        uri: function uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (_key) {\n            currentUri.key = _key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // prepare for the next URI\n\n\n          currentUri = {};\n        },\n        comment: function comment() {// comments are not important for playback\n        },\n        custom: function custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n      })[entry.type].call(self);\n    });\n\n    return _this;\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.push = function push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n  ;\n\n  _proto.end = function end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.type         the type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n  ;\n\n  _proto.addParser = function addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n  ;\n\n  _proto.addTagMapper = function addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  };\n\n  return Parser;\n}(Stream);\n\nexport { LineStream, ParseStream, Parser };","map":{"version":3,"sources":["/home/eduardo/Projects/videobrasil.online/node_modules/m3u8-parser/dist/m3u8-parser.es.js"],"names":["window","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_assertThisInitialized","self","ReferenceError","Stream","listeners","_proto","on","type","listener","push","off","index","indexOf","splice","trigger","callbacks","args","Array","slice","dispose","pipe","destination","data","LineStream","_Stream","_this","buffer","nextNewline","substring","attributeSeparator","value","keyvalue","RegExp","parseAttributes","attributes","attrs","split","result","attr","exec","replace","ParseStream","customParsers","tagMappers","line","_this2","match","event","trim","uri","newLines","reduce","acc","mapper","mappedLine","concat","forEach","newLine","text","tagType","duration","parseFloat","title","parseInt","version","number","playlistType","offset","allowed","test","URI","BYTERANGE","_attributes$BYTERANGE","byterange","RESOLUTION","resolution","width","height","BANDWIDTH","dateTimeString","dateTimeObject","Date","IV","toLowerCase","Uint32Array","PRECISE","addParser","_ref","_this3","expression","customType","dataParser","segment","addTagMapper","_ref2","map","mapFn","decodeB64ToUint8Array","b64Text","decodedString","atob","array","Uint8Array","charCodeAt","Parser","lineStream","parseStream","uris","currentUri","currentMap","_key","noop","defaultMediaGroups","widevineUuid","currentTimeline","manifest","allowCache","discontinuityStarts","segments","entry","mediaGroup","rendition","tag","message","endlist","endList","inf","mediaSequence","discontinuitySequence","METHOD","KEYFORMAT","VALID_METHODS","KEYID","contentProtection","schemeIdUri","keyId","pssh","method","iv","isFinite","playlist","streamInf","playlists","mediaGroups","media","TYPE","NAME","mediaGroupType","default","DEFAULT","autoselect","AUTOSELECT","LANGUAGE","language","instreamId","CHARACTERISTICS","characteristics","FORCED","forced","discontinuity","programDateTime","targetduration","targetDuration","totalduration","totalDuration","start","isNaN","timeOffset","precise","cueOut","cueOutCont","cueIn","timeline","comment","custom","chunk","end","options"],"mappings":"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","sourcesContent":["/*! @name m3u8-parser @version 4.4.0 @license Apache-2.0 */\nimport window from 'global/window';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implementation that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream =\n/*#__PURE__*/\nfunction () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n    var i;\n    var length;\n    var args;\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      length = callbacks.length;\n\n      for (i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      args = Array.prototype.slice.call(arguments, 1);\n      length = callbacks.length;\n\n      for (i = 0; i < length; ++i) {\n        callbacks[i].apply(this, args);\n      }\n    }\n  }\n  /**\n   * Destroys the stream and cleans up.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nvar LineStream =\n/*#__PURE__*/\nfunction (_Stream) {\n  _inheritsLoose(LineStream, _Stream);\n\n  function LineStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.buffer = '';\n    return _this;\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  var _proto = LineStream.prototype;\n\n  _proto.push = function push(data) {\n    var nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  };\n\n  return LineStream;\n}(Stream);\n\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\nvar attributeSeparator = function attributeSeparator() {\n  var key = '[^=]*';\n  var value = '\"[^\"]*\"|[^,]*';\n  var keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nvar parseAttributes = function parseAttributes(attributes) {\n  // split the string using attributes as the separator\n  var attrs = attributes.split(attributeSeparator());\n  var result = {};\n  var i = attrs.length;\n  var attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nvar ParseStream =\n/*#__PURE__*/\nfunction (_Stream) {\n  _inheritsLoose(ParseStream, _Stream);\n\n  function ParseStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.customParsers = [];\n    _this.tagMappers = [];\n    return _this;\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  var _proto = ParseStream.prototype;\n\n  _proto.push = function push(line) {\n    var _this2 = this;\n\n    var match;\n    var event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    var newLines = this.tagMappers.reduce(function (acc, mapper) {\n      var mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(function (newLine) {\n      for (var i = 0; i < _this2.customParsers.length; i++) {\n        if (_this2.customParsers[i].call(_this2, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        _this2.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n\n        return;\n      }\n\n      match = /^#EXTINF:?([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#ZEN-TOTAL-DURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'totalduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'byterange'\n        };\n\n        if (match[1]) {\n          event.length = parseInt(match[1], 10);\n        }\n\n        if (match[2]) {\n          event.offset = parseInt(match[2], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          var attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            var _attributes$BYTERANGE = attributes.BYTERANGE.split('@'),\n                length = _attributes$BYTERANGE[0],\n                offset = _attributes$BYTERANGE[1];\n\n            event.byterange = {};\n\n            if (length) {\n              event.byterange.length = parseInt(length, 10);\n            }\n\n            if (offset) {\n              event.byterange.offset = parseInt(offset, 10);\n            }\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            var split = event.attributes.RESOLUTION.split('x');\n            var resolution = {};\n\n            if (split[0]) {\n              resolution.width = parseInt(split[0], 10);\n            }\n\n            if (split[1]) {\n              resolution.height = parseInt(split[1], 10);\n            }\n\n            event.attributes.RESOLUTION = resolution;\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-START:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      } // unknown tag type\n\n\n      _this2.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n  ;\n\n  _proto.addParser = function addParser(_ref) {\n    var _this3 = this;\n\n    var expression = _ref.expression,\n        customType = _ref.customType,\n        dataParser = _ref.dataParser,\n        segment = _ref.segment;\n\n    if (typeof dataParser !== 'function') {\n      dataParser = function dataParser(line) {\n        return line;\n      };\n    }\n\n    this.customParsers.push(function (line) {\n      var match = expression.exec(line);\n\n      if (match) {\n        _this3.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType: customType,\n          segment: segment\n        });\n\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n  ;\n\n  _proto.addTagMapper = function addTagMapper(_ref2) {\n    var expression = _ref2.expression,\n        map = _ref2.map;\n\n    var mapFn = function mapFn(line) {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  };\n\n  return ParseStream;\n}(Stream);\n\nfunction decodeB64ToUint8Array(b64Text) {\n  var decodedString = window.atob(b64Text || '');\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}\n\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\n\nvar Parser =\n/*#__PURE__*/\nfunction (_Stream) {\n  _inheritsLoose(Parser, _Stream);\n\n  function Parser() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.lineStream = new LineStream();\n    _this.parseStream = new ParseStream();\n\n    _this.lineStream.pipe(_this.parseStream);\n    /* eslint-disable consistent-this */\n\n\n    var self = _assertThisInitialized(_this);\n    /* eslint-enable consistent-this */\n\n\n    var uris = [];\n    var currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    var currentMap; // if specified, the active decryption key\n\n    var _key;\n\n    var noop = function noop() {};\n\n    var defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    var widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    var currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    _this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: []\n    }; // update the manifest with the m3u8 entry from the parse stream\n\n    _this.parseStream.on('data', function (entry) {\n      var mediaGroup;\n      var rendition;\n      ({\n        tag: function tag() {\n          // switch based on the tag type\n          (({\n            'allow-cache': function allowCache() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n            byterange: function byterange() {\n              var byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  this.trigger('info', {\n                    message: 'defaulting offset to zero'\n                  });\n                  entry.offset = 0;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n            },\n            endlist: function endlist() {\n              this.manifest.endList = true;\n            },\n            inf: function inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n            key: function key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                _key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                var VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = {\n                  'com.widevine.alpha': {\n                    attributes: {\n                      schemeIdUri: entry.attributes.KEYFORMAT,\n                      // remove '0x' from the key id string\n                      keyId: entry.attributes.KEYID.substring(2)\n                    },\n                    // decode the base64-encoded PSSH box\n                    pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                  }\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              _key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                _key.iv = entry.attributes.IV;\n              }\n            },\n            'media-sequence': function mediaSequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n            'discontinuity-sequence': function discontinuitySequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n            'playlist-type': function playlistType() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n            map: function map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n            },\n            'stream-inf': function streamInf() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n            media: function media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n            discontinuity: function discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n            'program-date-time': function programDateTime() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n            },\n            targetduration: function targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n            },\n            totalduration: function totalduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid total duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.totalDuration = entry.duration;\n            },\n            start: function start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n            'cue-out': function cueOut() {\n              currentUri.cueOut = entry.data;\n            },\n            'cue-out-cont': function cueOutCont() {\n              currentUri.cueOutCont = entry.data;\n            },\n            'cue-in': function cueIn() {\n              currentUri.cueIn = entry.data;\n            }\n          })[entry.tagType] || noop).call(self);\n        },\n        uri: function uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (_key) {\n            currentUri.key = _key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // prepare for the next URI\n\n\n          currentUri = {};\n        },\n        comment: function comment() {// comments are not important for playback\n        },\n        custom: function custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n      })[entry.type].call(self);\n    });\n\n    return _this;\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.push = function push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n  ;\n\n  _proto.end = function end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.type         the type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n  ;\n\n  _proto.addParser = function addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n  ;\n\n  _proto.addTagMapper = function addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  };\n\n  return Parser;\n}(Stream);\n\nexport { LineStream, ParseStream, Parser };\n"]},"metadata":{},"sourceType":"module"}